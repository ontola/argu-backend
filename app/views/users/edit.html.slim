=set_title t('users.settings')
=render partial: 'profiles/profile_bar', locals: {active: :settings}
.col-1
  header
    h1= t('users.settings')
  .box
    =semantic_form_for @user, url: settings_path, method: :put do |f|
      section.inspectlet-sensitive
        =f.semantic_errors :email, :base
        =f.inputs name: t('users.registrations.categories.general') do
          //p= t('profiles.edit.shortname_not_allowed')
          =f.inputs :shortname, for: :shortname, disabled: true
          li.form-helper
            span=t('profiles.edit.shortname_not_allowed')
          =f.input :email, label: t('users_email'), value: @user.email, placeholder: @user.email.blank? ? t('users_email_placeholder') : @user.email
          li.form-helper
            - if @user.confirmed_at.present?
              span= t('users.registrations.confirmed')
            - else
              span
                =t('users.registrations.unconfirmed')
                =link_to " (#{t('devise.confirmations.send')})", user_confirmation_path(user: {email: @user.email}), rel: :nofollow, data: {method: :post}
          =f.input :time_zone
          =f.input :language, as: :react_select, collection: I18n.available_locales, include_blank: false
          =f.input :country, as: :react_country, priority_countries: %w(NL BE)
          =f.input :birthday, as: :date_picker
        - if active_for_user?(:email_notifications, current_user)
          =f.inputs name: t('users.registrations.categories.notifications'), class: 'danger-zone' do
            p= t('notifications.email.beta')
            =f.input :follows_email, as: :react_select, collection: options_for_follows_email, include_blank: false
        =f.inputs name: t('users.registrations.categories.privacy') do
          =f.input :has_analytics, as: :reverse_boolean
          li.form-helper
            span= t('users.edit.analytics_helper')
          =f.semantic_fields_for :profile do |profile|
            =profile.input :are_votes_public, as: :reverse_boolean
        =f.inputs name: t('users.registrations.categories.authentication') do
          -if @user.password_required?
            =f.input :password, label: t('users_password_edit'), required: @user.new_record?
            =f.input :password_confirmation, label: t('users_password_confirmation')
            =f.input :current_password
          -else
            / TODO: Only show this if user does not have a password.
            p
              =t('users.registrations.no_password')
              =link_to " #{t('devise.passwords.new.submit')}.", password_path(@user), data: {method: :post, :'skip-pjax' => true}, rel: :nofollow
          - if @user.identities.present?
            label= t('users_oauth_coupled')
            =render partial: 'authentications/login_providers_connected', locals: { identities: @user.identities, show_decouple: (@user.password_required? || @user.identities.length > 1) }

          /TODO Hide authentications that are already present.
          - if login_providers_left(@user).present?
            label= t('users_oauth_new')
            .form-item
              =render partial: 'authentications/login_providers', locals: {providers: login_providers_left(@user)}
          - elsif !@user.password_required? && @user.identities.length == 1
            p= t('users.authentications.cant_decouple_note_provider', provider: @user.identities.first.provider)

        =f.inputs name: t('forms.danger_zone'), class: 'danger-zone' do
          label= t('users_cancel_title')
          .form-item
            =link_to t('users_cancel_title'), cancel_user_registration_path(current_user)

        =f.actions do
          =f.action :submit, :as => :button, label: t('save')
