=set_title blog_post.new_record? ? t('new_type', type: t('blog_posts.type')) : t('edit_type', type: t('blog_posts.type'))
.col-3
  .col-3-2
    =to_parent
    .box
      =render partial: 'blog_posts/info_bar', locals: {blog_post: blog_post}
      =semantic_form_for(blog_post.new_record? ? [get_parent_resource, blog_post] : blog_post, html: {autocomplete: 'off'}) do |f|
        section.smallpadded.form-filled
          =f.inputs
            =f.input :title, as: :text, input_html: {size: '2', maxlength: '110', class: 'blog-post-t form-input-title', autofocus: :autofocus}, label: false, hint: false, placeholder: placeholder_for(blog_post, :title, motion_type(blog_post).downcase)
            =f.input :content, input_html: {class: 'form-input-content', rows: '8'}, label: false, hint: false, placeholder: placeholder_for(blog_post, :content, motion_type(blog_post).downcase)
            =f.input :published_at, as: :datetime_picker
          -if !blog_post.new_record? && policy(blog_post).trash?
            =f.inputs name: t('forms.danger_zone'), class: 'danger-zone' do
              - if policy(blog_post).trash?
                =f.input :trashed_at, as: :reverse_boolean
            - if blog_post.is_published? && policy(blog_post).destroy?
              =f.input :unpublish, as: :reverse_boolean, checked_value: 'true', unchecked_value: 'false'
        section.section--footer
          - if blog_post.new_record?
            =render partial: 'profiles/profile_current'
          - else
            =render partial: blog_post.creator, locals: {resource: blog_post}
          =f.actions
            .sticky-submit
              =f.action :submit, as: :button
  /TODO make translations, make content dependent on focus field
  .col-3-1
    =render partial: 'markdown_helper'
